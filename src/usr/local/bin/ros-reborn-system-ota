#!/bin/bash

## SPDX-License-Identifier: GPL-3.0-or-later
## Copyright (C) 2026 Le Nguyen Hoang Gia Phu <crystalforceix@gmail.com>

set -eo pipefail

# Constants

REBORN_DIR="/rengeos-reborn"
TMP_DIR="${REBORN_DIR}/tmp"
OS_RELEASE="/etc/os-release"
TMP_OS_RELEASE="${TMP_DIR}/os-release"
GITHUB_REPO="RengeOS/ROS-Reborn-System-OTA"
PREFLIGHT_OS_RELEASE="/tmp/ros-reborn-preflight-os-release"
LOG_FILE="/tmp/ros-reborn-system-ota.log"

# Logging

log()     { echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"; }
info()    { echo "[INFO] $*"    | tee -a "$LOG_FILE"; }
success() { echo "[SUCCESS] $*" | tee -a "$LOG_FILE"; }

error() {
	echo "[ERROR] $*" | tee -a "$LOG_FILE"
	if command -v dialog &>/dev/null; then
		dialog --title "Error" --msgbox "$*\n\nCheck log: $LOG_FILE" 12 70
	fi
	rm -rf "$TMP_DIR" 2>/dev/null || true
	rm -f "$PREFLIGHT_OS_RELEASE" 2>/dev/null || true
	exit 1
}

# Cleanup

cleanup_on_exit() {
	local exit_code=$?
	log "Script exiting with code: $exit_code"
	rm -f /tmp/download_progress_$$_*.fifo 2>/dev/null || true
	rm -f "$PREFLIGHT_OS_RELEASE" 2>/dev/null || true
	pkill -P $$ dialog 2>/dev/null || true
	if [[ $exit_code -ne 0 ]]; then
		log "Script terminated with error - cleaning up temporary directory"
		rm -rf "$TMP_DIR" 2>/dev/null || true
	fi
}

trap cleanup_on_exit EXIT INT TERM

# Prerequisite checks

check_root() {
	log "Checking root privileges..."
	if [[ "$EUID" -ne 0 ]]; then
		error "This script must be run as root"
	fi
	log "Root privileges confirmed"
}

check_requirements() {
	log "Checking required tools..."
	local missing_tools=()

	for tool in dialog wget; do
		if ! command -v "$tool" &>/dev/null; then
			missing_tools+=("$tool")
			log "WARNING: Missing tool: $tool"
		fi
	done

	if [[ ${#missing_tools[@]} -gt 0 ]]; then
		error "Missing required tools: ${missing_tools[*]}\nPlease install: sudo pacman -S ${missing_tools[*]}"
	fi

	log "All required tools are available"
}

# Version helper
# Reads IMAGE_VERSION from an os-release file without sourcing it.
# Returns "Unknown" if the field is not found.

get_version_from_file() {
	local file="$1"
	local version
	version=$(grep '^IMAGE_VERSION=' "$file" 2>/dev/null | cut -d= -f2 | tr -d '"') || true
	echo "${version:-Unknown}"
}

# Pre-flight fetch of os-release only

fetch_preflight_os_release() {
	log "Fetching os-release from latest release for version check..."
	dialog --infobox "Fetching latest version info from GitHub..." 5 50
	sleep 0.5

	rm -f "$PREFLIGHT_OS_RELEASE"

	# Resolve the direct download URL for os-release via the GitHub API
	# to avoid depending on redirect behaviour in wget.
	# Each grep is guarded with || true so a no-match does not abort under set -eo pipefail.
	local api_json direct_url
	api_json=$(wget -qO- --timeout=15 \
		"https://api.github.com/repos/${GITHUB_REPO}/releases/latest" 2>>"$LOG_FILE") || true

	direct_url=$(echo "$api_json" \
		| grep '"browser_download_url"' \
		| grep 'os-release' \
		| cut -d '"' -f4 \
		| head -1) || true

	if [[ -z "$direct_url" ]]; then
		log "WARNING: os-release not listed in release assets, falling back to redirect URL"
		direct_url="https://github.com/${GITHUB_REPO}/releases/latest/download/os-release"
	fi

	log "Downloading os-release from: $direct_url"

	if ! wget -q --timeout=15 --max-redirect=5 "$direct_url" -O "$PREFLIGHT_OS_RELEASE" 2>>"$LOG_FILE"; then
		rm -f "$PREFLIGHT_OS_RELEASE"
		error "Failed to fetch version info from GitHub.\nPlease check your internet connection."
	fi

	if [[ ! -s "$PREFLIGHT_OS_RELEASE" ]]; then
		rm -f "$PREFLIGHT_OS_RELEASE"
		error "Downloaded os-release is empty. The release may not include this file."
	fi

	log "Preflight os-release saved to $PREFLIGHT_OS_RELEASE"
}

# Version comparison dialog
# Shows only the two IMAGE_VERSION values (which are dates) side by side.

show_version_confirm_dialog() {
	local current_ver="$1"
	local new_ver="$2"
	local status="$3"

	local status_line
	case "$status" in
		newer)   status_line="A newer version is available." ;;
		older)   status_line="WARNING: The remote version is OLDER than your current version." ;;
		unknown) status_line="Version comparison could not be determined." ;;
	esac

	local msg
	printf -v msg \
		'%s\n\n  %-16s %s\n  %-16s %s\n\n%s\n\nDo you want to download and apply this update?' \
		"Version comparison:" \
		"Current:" "$current_ver" \
		"Latest:"  "$new_ver" \
		"$status_line"

	dialog --title "Confirm Update" --defaultno --yesno "$msg" 16 70
}

# Download all release files

download_all_release_files() {
	local tmp_dir="$1"
	log "Downloading all files from latest release..."
	log "Target directory: $tmp_dir"

	cd "$tmp_dir" || error "Failed to change to directory: $tmp_dir"

	local api_json download_urls
	api_json=$(wget -qO- "https://api.github.com/repos/${GITHUB_REPO}/releases/latest") || true
	download_urls=$(echo "$api_json" \
		| grep "browser_download_url" \
		| cut -d '"' -f4) || true

	if [[ -z "$download_urls" ]]; then
		error "No files found in the latest release."
	fi

	local url_array=()
	while IFS= read -r url; do
		[[ -n "$url" ]] && url_array+=("$url")
	done <<<"$download_urls"

	local total_files=${#url_array[@]}
	log "Found $total_files file(s) to download"

	local current_file=0
	for download_url in "${url_array[@]}"; do
		current_file=$((current_file + 1))
		local filename
		filename=$(basename "$download_url")
		log "Downloading file $current_file/$total_files: $filename"

		local fifo="/tmp/download_progress_$$_${current_file}.fifo"
		rm -f "$fifo" 2>/dev/null || true
		mkfifo "$fifo" || error "Failed to create progress pipe"

		dialog --title "Downloading Files" \
			--gauge "File: $filename ($current_file/$total_files)" 10 70 0 <"$fifo" &
		local dialog_pid=$!

		exec 3>"$fifo"

		local download_success=0
		(
			echo "0"
			echo "XXX"; echo "Starting download: $filename"; echo "XXX"

			if wget --progress=bar:force "$download_url" -O "$filename" 2>&1 \
				| stdbuf -oL tr '\r' '\n' \
				| stdbuf -oL grep -oP '[0-9]+(?=%)' \
				| while read -r percent; do
					echo "$percent"
					echo "XXX"; echo "Downloading $filename ($current_file/$total_files) - ${percent}%"; echo "XXX"
				done; then
				echo "100"
				echo "XXX"; echo "Download complete: $filename"; echo "XXX"
				sleep 0.5
				exit 0
			else
				echo "0"
				echo "XXX"; echo "Download failed: $filename"; echo "XXX"
				sleep 1
				exit 1
			fi
		) >&3
		download_success=$?

		exec 3>&-
		wait "$dialog_pid" 2>/dev/null || true
		rm -f "$fifo"

		if [[ $download_success -ne 0 ]] || [[ ! -f "$filename" ]]; then
			error "Failed to download: $filename"
		fi

		log "Successfully downloaded: $filename ($(du -h "$filename" | cut -f1))"
	done

	cd - >/dev/null || true
	log "All files downloaded successfully"
}

# Apply the update

apply_update() {
	local current_version="$1"
	local new_version="$2"

	(
		echo "10"; echo "XXX"; echo "Deleting old airootfs..."; echo "XXX"
		log "Deleting old airootfs from ${REBORN_DIR}/airootfs/"
		rm -rf "${REBORN_DIR}/airootfs/"*
		log "Old airootfs deleted"

		echo "30"; echo "XXX"; echo "Deleting old kernel..."; echo "XXX"
		log "Deleting old kernel from ${REBORN_DIR}/kernel/"
		rm -rf "${REBORN_DIR}/kernel/"*
		log "Old kernel deleted"

		echo "50"; echo "XXX"; echo "Copying new airootfs.sfs..."; echo "XXX"
		log "Copying new airootfs.sfs"
		mkdir -p "${REBORN_DIR}/airootfs"
		local airootfs_file
		airootfs_file=$(find "$TMP_DIR" -name "airootfs.sfs" -print -quit)
		if [[ -n "$airootfs_file" ]]; then
			mv "$airootfs_file" "${REBORN_DIR}/airootfs/"
			log "New airootfs.sfs copied successfully"
		else
			log "WARNING: airootfs.sfs not found in downloaded files"
		fi

		echo "70"; echo "XXX"; echo "Copying new kernel..."; echo "XXX"
		log "Copying new kernel"
		mkdir -p "${REBORN_DIR}/kernel"
		local kernel_count
		kernel_count=$(find "$TMP_DIR" -name "vmlinuz-*" | wc -l)
		if [[ "$kernel_count" -gt 0 ]]; then
			find "$TMP_DIR" -name "vmlinuz-*" -exec mv {} "${REBORN_DIR}/kernel/" \;
			log "Copied $kernel_count kernel file(s) successfully"
		else
			log "WARNING: No kernel files (vmlinuz-*) found in downloaded files"
		fi

		echo "85"; echo "XXX"; echo "Updating /etc/os-release..."; echo "XXX"
		log "Replacing $OS_RELEASE with $TMP_OS_RELEASE"
		if [[ -f "$TMP_OS_RELEASE" ]]; then
			rm -f "$OS_RELEASE"
			cp "$TMP_OS_RELEASE" "$OS_RELEASE"
			log "$OS_RELEASE replaced successfully"
		else
			log "WARNING: $TMP_OS_RELEASE not found, patching IMAGE_VERSION only"
			sed -i '/^IMAGE_VERSION=/d' "$OS_RELEASE" 2>/dev/null || true
			echo "IMAGE_VERSION=${new_version}" >>"$OS_RELEASE"
		fi

		echo "95"; echo "XXX"; echo "Cleaning up..."; echo "XXX"
		log "Removing temporary directory: $TMP_DIR"
		rm -rf "$TMP_DIR"
		log "Temporary directory removed"

		echo "100"; echo "XXX"; echo "Complete!"; echo "XXX"
		sleep 1
	) | dialog --title "Updating System" --gauge "Starting update process..." 10 70 0
}

# Main

main() {
	log "ROS-Reborn-System-OTA started"
	log "Log file: $LOG_FILE"

	clear
	check_root
	check_requirements

	local current_version
	current_version=$(get_version_from_file "$OS_RELEASE")
	log "Current system version: $current_version"


	dialog --title "ROS-Reborn-System-OTA" --msgbox \
		"Essentially, this is a tool for updating the backup system before ros-reborn uses it on the main system.\n\nIt will update the ros-reborn backup system to the latest version of the RengeOS ISO. It can help you install the latest RengeOS system with ros-reborn, ensuring you always use the newest version from the RengeOS ISO build, instead of the older version as before.\n" \
		16 70

	log "Asking user to proceed to version check"
	if ! dialog --title "Check for Updates" --yesno \
		"Do you want to check for the latest version?\n\nThe script will fetch only the release version info from GitHub to compare with your current system before downloading anything." \
		10 65; then
		log "User cancelled at version check prompt"
		clear
		echo "Update cancelled."
		exit 0
	fi

	fetch_preflight_os_release

	local new_version
	new_version=$(get_version_from_file "$PREFLIGHT_OS_RELEASE")
	log "Remote release version: $new_version"


	if [[ "$new_version" == "Unknown" ]]; then
		error "Unable to determine the latest version from the fetched os-release file."
	fi

	local status
	if [[ "$new_version" == "$current_version" ]]; then
		status="same"
	elif [[ "$new_version" > "$current_version" ]]; then
		status="newer"
	else
		status="older"
	fi
	log "Version comparison result: $status (current=$current_version, latest=$new_version)"

	if [[ "$status" == "same" ]]; then
		log "System is already on the latest version: $new_version"
		dialog --title "Up To Date" --msgbox \
			"Your system is already on the latest version.\n\n${new_version}" \
			8 50
		clear
		exit 0
	fi

	log "Showing version comparison dialog (status=$status)"
	if ! show_version_confirm_dialog "$current_version" "$new_version" "$status"; then
		log "User declined update after seeing version comparison"
		clear
		echo "Update cancelled."
		exit 0
	fi

	log "User confirmed - proceeding with full release download"
	rm -f "$PREFLIGHT_OS_RELEASE"

	dialog --infobox "Creating temporary directory..." 5 40
	rm -rf "$TMP_DIR" 2>/dev/null || true
	mkdir -p "$TMP_DIR" || error "Failed to create directory: $TMP_DIR"
	log "Temporary directory created: $TMP_DIR"

	download_all_release_files "$TMP_DIR"

	local confirmed_version
	confirmed_version=$(get_version_from_file "$TMP_OS_RELEASE")
	if [[ "$confirmed_version" == "Unknown" ]]; then
		rm -rf "$TMP_DIR"
		error "Unable to determine new version from downloaded os-release file."
	fi
	log "Confirmed new version from full download: $confirmed_version"

	log "Starting update: $current_version -> $confirmed_version"
	apply_update "$current_version" "$confirmed_version"
	log "Update process completed successfully"

	dialog --title "Complete" --msgbox \
		"Everything is complete!\n\nUpdated version from ${current_version} to ${confirmed_version}.\n\nROS-Reborn system is ready to use.\n\nLog file: ${LOG_FILE}" \
		14 70

	clear
	success "Update successful! ${current_version} -> ${confirmed_version}"
	log "Old version: $current_version"
	log "New version: $confirmed_version"
	echo "Old version: ${current_version}"
	echo "New version: ${confirmed_version}"
	echo "Log file: ${LOG_FILE}"
}

main "$@"
